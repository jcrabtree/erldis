%%
%% @doc This module implements a hash ring.
%% Items are hashed into the ring NumReplicas times.
%%
%% An item is hashed using the following:
%%
%% sha1(Item + string(N)) where N is (1..NumReplicas)
%%
%% Note: When N is converted to a string it is not zero padded.
%%
-module(hash_ring).

-export([
  create_ring/2,
  get_item/2,
  add_item/2,
  remove_item/2
]).

%%
%% @doc Finds the item that contains the Key on the Ring
%%
get_item(Key, {_NumReplicas, Circle}) when is_list(Circle) ->
    get_item_array(Key, array:from_list(Circle));
    
get_item(Key, {_NumReplicas, Circle}) ->
    get_item_array(Key, Circle).
    
get_item_array(Key, Array) ->
    Point = hash_key(Key),
    find_next_highest_item(Point, Array, 0, array:size(Array)).

find_next_highest_item(_Point, Items, A, B) when (A + 1) == B ->
    element(1, array:get(B - 1, Items));
 
find_next_highest_item(_Point, [], _, _)  ->
    undefined;
  
find_next_highest_item(Point, Points, A, B) ->
    NumPoints = B - A,
    Halfway = round(NumPoints / 2),
    {Item, HalfwayPoint} = array:get(A + Halfway - 1, Points),
    if 
        Point == HalfwayPoint ->
            Item;
        HalfwayPoint > Point ->
            find_next_highest_item(Point, Points, A, B - Halfway);
        true ->
            % upper half
            find_next_highest_item(Point, Points, A + Halfway, B)
    end.

%%
%% @doc Creates a hash ring that places Items in the ring NumReplicas times
%%
%% A "replica" just means that the Item is placed on the ring in multiple places to 
%% make the distribution more even.
%%
create_ring(Items, NumReplicas) ->
    lists:foldl(fun(Item, Ring) ->
        add_item(Item, Ring)
    end, {NumReplicas, []}, Items).

%%
%% @doc Adds an item into the ring.
%% Returns the ring with item added in.
%% 
add_item(Item, {NumReplicas, Circle}) ->
    sort_ring({NumReplicas, lists:flatten(lists:append(Circle, get_item_points(Item, NumReplicas)))}).

%%
%% @doc Removes an item and its replicas from the ring.
%% Returns the ring without the item.
%%    
remove_item(Item, {NumReplicas, Circle}) ->
    Points = get_item_points(Item, NumReplicas),
    sort_ring({NumReplicas, lists:filter(fun(Point) -> 
        not lists:member(Point, Points)
    end, Circle)}).

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Internal functions
%%%%%%%%%%%%%%%%%%%%%%%%%%%

sort_ring({NumReplicas, Circle}) ->
    {NumReplicas, lists:usort(fun({_ItemA, PartitionA}, {_ItemB, PartitionB}) ->
        PartitionA =< PartitionB
    end, Circle)}.

%%
%% @doc This function returns a list of N {Item, Point} tuples
%% 
%% Each point is generated by hashing (item + 1) to (item + n) to evenly distribute the points
%%
get_item_points(Item, N) ->
  lists:map(fun(Partition) ->
    {Item, Partition}
  end,
  lists:usort(lists:map(fun(X) ->
    hash_key(Item ++ integer_to_list(X))
  end, lists:seq(1, N)))).

%%
%% Hashes the given Key with SHA1 and converts it to a big integer
%%
hash_key(Key) when is_binary(Key) ->
    hash_key(binary_to_list(Key));
hash_key(Key) ->
  <<Int:160/unsigned-integer>> = crypto:sha(Key),
  Int.
  

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Tests
%%%%%%%%%%%%%%%%%%%%%%%%%%%
-ifdef(TEST).

-include_lib("eunit/include/eunit.hrl").

hash_key_known_test() ->
  lists:foreach(fun(_) ->
    ?assertEqual(653878565946713713149629104275478104571867727804, hash_key("test123"))
  end, lists:seq(1, 1000)).

add_remove_item_test() ->
    Ring = create_ring([], 2),
    
    PointA1 = hash_key("A1"),
    PointA2 = hash_key("A2"),
    PointB1 = hash_key("B1"),
    PointB2 = hash_key("B2"),
    
    AddedRing = add_item("B", add_item("A", Ring)),
    ?assertEqual({2, [
        {"A", PointA1},
        {"A", PointA2},
        {"B", PointB2},
        {"B", PointB1}
    ]}, AddedRing),
    
    RemovedRing = remove_item("A", AddedRing),
    ?assertEqual({2, [
        {"B", PointB2},
        {"B", PointB1}
    ]}, RemovedRing).

-endif.
